"""
This type stub file was generated by pyright.
"""

'''
Utils
=====

'''
__all__ = ('platform', 'reify', 'deprecated')
class Platform:
    '''
    Refactored to class to allow module function to be replaced
    with module variable.
    '''
    def __init__(self) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    


platform = ...
class Proxy:
    '''
    Based on http://code.activestate.com/recipes/496741-object-proxying
    version by Tomer Filiba, PSF license.
    '''
    __slots__ = ...
    def __init__(self, name, facade) -> None:
        ...
    
    def __getattribute__(self, name): # -> Any | None:
        ...
    
    def __delattr__(self, name): # -> None:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def whereis_exe(program): # -> str | None:
    ''' Tries to find the program on the system path.
        Returns the path if it is found or None if it's not found.
    '''
    ...

class reify:
    '''
    Put the result of a method which uses this (non-data) descriptor decorator
    in the instance dict after the first call, effectively replacing the
    decorator with an instance variable.

    It acts like @property, except that the function is only ever called once;
    after that, the value is cached as a regular attribute. This gives you lazy
    attribute creation on objects that are meant to be immutable.

    Taken from the `Pyramid project <https://pypi.python.org/pypi/pyramid/>`_.

    To use this as a decorator::

         @reify
         def lazy(self):
              ...
              return hard_to_compute_int
         first_time = self.lazy   # lazy is reify obj, reify.__get__() runs
         second_time = self.lazy  # lazy is hard_to_compute_int
    '''
    def __init__(self, func) -> None:
        ...
    
    def __get__(self, inst, cls): # -> Self@reify:
        ...
    


def deprecated(obj): # -> ((*args: Unknown, **kwargs: Unknown) -> Unknown) | None:
    '''
    This is a decorator which can be used to mark functions and classes as
    deprecated. It will result in a warning being emitted when a deprecated
    function is called or a new instance of a class created.

    In case of classes, the warning is emitted before the __new__ method
    of the decorated class is called, therefore a way before the __init__
    method itself.
    '''
    ...

